<?php

namespace App\StorableEvents;

use App\Domain\Clients\Models\Client;
use App\Domain\Clients\Projections\ClientActivity;
use App\Domain\Users\Models\User;
use Carbon\CarbonImmutable;
use Illuminate\Support\Facades\Log;
use Spatie\EventSourcing\Enums\MetaData;
use Spatie\EventSourcing\Facades\Projectionist;
use Spatie\EventSourcing\StoredEvents\Models\EloquentStoredEvent;

class GymRevStoredEvent extends EloquentStoredEvent
{
    public static function boot()
    {
        parent::boot();

        static::creating(function (GymRevStoredEvent $storedEvent) {
            if (! Projectionist::isReplaying()) {
                $user_id = null;
                if (session('user_id')) {
                    $user_id = session('user_id');
                }
                $access_token = request()->bearerToken() ?? null;
                $ip = request()->ip() ?? null;
                $api_user_id = $access_token !== null ? User::whereAccessToken($access_token)->firstOrFail()->id : null;

                $auto_generated = $user_id === null && $access_token === null;

                $storedEvent->meta_data['user_id'] = $user_id;
                $storedEvent->meta_data['api_user_id'] = $api_user_id;
                $storedEvent->meta_data['access_token'] = $access_token;
                $storedEvent->meta_data['auto-generated'] = $auto_generated;
                $storedEvent->meta_data['ip-address'] = $ip;
            }
        });
        static::created(function (GymRevStoredEvent $storedEvent) {
            Log::info('client ' . $storedEvent->clientId());
            Log::info('entity ' . $storedEvent->entity());
            if ($storedEvent->clientId() && $storedEvent->entity()) {
                (new ClientActivity())->writeable()->create([
                    'stored_event_id' => $storedEvent->id,
                    'client_id' => $storedEvent->clientId(),
                    'entity' => $storedEvent->entity(),
                    'entity_id' => $storedEvent->entityId(),
                    'operation' => $storedEvent->operation(),
                    'user_id' => $storedEvent->userId(),
                    'api_user_id' => $storedEvent->accessToken() ? $storedEvent->apiUser()->id : null,
                    'access_token' => $storedEvent->accessToken(),
                    'ip_address' => $storedEvent->ipAddress(),
                    'created_at' => $storedEvent->createdAt(),
                ]);
            }
        });
    }

    public function operation(): ?string
    {
        return $this->meta_data['operation'] ?? null;
    }

    //TODO: use enums for the meta_data keys
    public function autoGenerated(): bool
    {
//        return $this->meta_data[meta_data::STORED_EVENT_ID] ?? null;
        return $this->meta_data['auto-generated'] ?? false;
    }

    public function userId(): ?int
    {
        return $this->meta_data['user_id'] ?? null;
    }

    public function accessToken(): ?string
    {
        return $this->meta_data['access_token'] ?? null;
    }

    public function ipAddress(): ?string
    {
        return $this->meta_data['ip-address'] ?? null;
    }

    public function createdAt(): ?CarbonImmutable
    {
        return CarbonImmutable::make($this->metaData[MetaData::CREATED_AT] ?? null);
    }

    public function entity(): ?string
    {
        return $this->meta_data['entity'] ?? null;
    }

    public function entityId(): ?string
    {
        return $this->aggregate_uuid;
    }

    public function clientId(): ?string
    {
        if ($this->entity() === Client::class) {
            return $this->entityId();
        }

        return $this->meta_data['client_id'] ?? $this->event_properties['payload']['client_id'] ?? null;
    }

    public function user(): ?User
    {
        $userId = $this->userId();
        if (! $userId) {
            return null;
        }

        return User::withoutGlobalScopes()->find($userId);
    }

    public function apiUser(): ?User
    {
        $accessToken = $this->accessToken();
        if (! $accessToken) {
            return null;
        }

        return User::withoutGlobalScopes()->whereAccessToken($accessToken)->first();
    }
}
